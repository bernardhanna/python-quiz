[
{
    "category": "q2",
    "question": "Write a function get_next_birthday() which takes a singl string parameter representing someoneâ€™s date of birth in the format dd/mYYYY and determines their next birthday and returns a string representing their next birthday in the format dd/mm/YYYY. Form now just import datetime and def the function def get_next_birthday",
    "answer": "import datetime\n def get_next_birthday(dob_str):\n"
  },
  {
    "category": "q2",
    "question": "Convert the date of birth string into a date object",
    "answer": "dob = datetime.datetime.strptime(dob_str, '%d/%m/%Y')"
  },
  {
    "category": "q2",
    "question": "Get the current date",
    "answer": "current_date = datetime.datetime.now()"
  },
  {
    "category": "q2",
    "question": "Create a date object for their birthday this year",
    "answer": "this_year_birthday = dob.replace(year=current_date.year)"
  },
  {
    "category": "q2",
    "question": "Create a date object for their birthday this year",
    "answer": "this_year_birthday = dob.replace(year=current_date.year)"
  },
  {
    "category": "q2",
    "question": "If their birthday this year has passed, then Create a date object for their birthday next year",
    "answer": "if current_date > this_year_birthday:\n next_year_birthday = this_year_birthday.replace(year=current_date.year + 1)\n else: \n  next_year_birthday = this_year_birthday"
  },
  {
    "category": "q2",
    "question": "Return the birthday in the format dd/mm/YYYY",
    "answer": "return next_year_birthday.strftime('%d/%m/%Y')"
  },
  {
    "category": "q2",
    "question": "The Exhaustive Ballot is a voting system used to elect a single winner, where voters cast a single vote for their preferred candidate. If no candidate has received more than 50% of votes cast, then the candidate with the fewest votes is eliminated, and a further round of voting occurs. This process is repeated for as many rounds as necessary until one candidate has a majority.\n\nWrite a Python program which uses a dictionary to process the results of such an election.\n\nImportant: You may only import the sys module for this question. You may not import any other libraries, modules or features.\n\nInitialize the dictionary as follows:\n- Create an empty dictionary which will store the name of each candidate (as key) and the number of votes received (as value).\n- Use a loop to input the name of each candidate, until the user indicates they are finished. For each name entered, the candidate should be inserted into the dictionary as a key with a value of zero, unless the candidate already exists in the dictionary, in which case a suitable message should be displayed.\n- After the loop, check if the dictionary is empty, in which case a suitable message should be displayed and the program terminated using sys.exit().",
    "answer": "import sys\n\nresults = {}\nwhile True:\n candidate = input(\"Enter candidate's name or q to continue: \")\n if candidate == \"q\":\n break\n elif candidate in results:\n print(\"Candidate already included\")\n else:\n results[candidate] = 0\nif len(results) == 0:\n print(\"No candidates entered, quitting\")\n sys.exit()"
  },
  {
    "category": "q2",
    "question": "Use a loop to implement each round of voting as follows:\n- Display the round number and the number of candidates\n- Display the names of the candidates in alphabetical order and for each candidate, input the number of votes they received and update the corresponding dictionary value\n- Determine and display the total number of votes received by all candidates in the current round\n- Determine and display the name of each candidate, the number of votes received, and the percentage of the total, in order of votes received from highest to lowest\n- If the leading candidate has received more than 50% of the votes, what should you do?\n",
    "answer": "round = 1\neliminated = []\nwhile True:\n print(\"\\nRound:\", round)\n for candidate in sorted(results):\n results[candidate] = int(input(\"Enter the number of votes for \" + candidate + \": \"))\n print(\"Number of Candidates:\", len(results))\n total_votes = sum(results.values())\n print(\"Total Votes:\", total_votes)\n for candidate in sorted(results, key=results.get, reverse=True):\n print(f\"{candidate}: {results.get(candidate)} ({results.get(candidate)/total_votes:.1%})\")\n leader = max(results, key=results.get)\n print(\"Candidate with the most votes:\", leader)\n if results[leader]/total_votes > 0.5:\n break\n else:\n loser = min(results, key=results.get)\n print(\"Eliminating candidate with the least votes:\", loser)\n del results[loser]\n eliminated.append(loser)\n round += 1"
  },
  {
    "category": "q2",
    "question": "Display the results of the election, including:\n- The name of the winning candidate\n- The names of the eliminated candidates, along with the round number in which they were eliminated\n",
    "answer": "print(\"\\nWinner:\", leader)\nif len(eliminated) > 0:\n print(\"Eliminated Candidates\")\n print(\"Round Candidate\")\n for round in range(0,len(eliminated),):\n print(f\"{round+1:3} {eliminated[round]}\")"
  },
  {
    "category": "q2",
    "question": "The Exhaustive Ballot is a voting system used to elect a single winner, where voters cast a single vote for their preferred candidate. If no candidate has received more than 50% of votes cast, then the candidate with the fewest votes is eliminated, and a further round of voting occurs. This process is repeated for as many rounds as necessary until one candidate has a majority.\n\nWrite a Python program which uses a dictionary to process the results of such an election.\n\nImportant: You may only import the sys module and the datetime module for this question. You may not import any other libraries, modules, or features.\n\nInitialize the dictionary as follows:\n- Create an empty dictionary which will store the name of each candidate (as key) and the number of votes received (as value).\n- Use a loop to input the name of each candidate, until the user indicates they are finished. For each name entered, the candidate should be inserted into the dictionary as a key with a value of zero unless the candidate already exists in the dictionary, in which case a suitable message should be displayed.\n- After the loop, check if the dictionary is empty, in which case a suitable message should be displayed and the program terminated using sys.exit().",
    "answer": "import sys\nimport datetime\n\nresults = {}\nstart_time = datetime.datetime.now()\n\nwhile True:\n    candidate = input(\"Enter candidate's name or q to continue: \")\n    if candidate == \"q\":\n        break\n    elif candidate in results:\n        print(\"Candidate already included\")\n    else:\n        results[candidate] = 0\n\nif len(results) == 0:\n    print(\"No candidates entered, quitting\")\n    sys.exit()\n\nend_time = datetime.datetime.now()\ntime_taken = end_time - start_time\nprint(f\"Election started at {start_time}, ended at {end_time}\")\nprint(f\"Time taken for the election: {time_taken}\")"
  },
  {
    "category": "q2",
    "question": "Use a loop to implement each round of voting as follows:\n- Display the round number and the number of candidates\n- Display the names of the candidates in alphabetical order and for each candidate, input the number of votes they received and update the corresponding dictionary value\n- Determine and display the total number of votes received by all candidates in the current round\n- Determine and display the name of each candidate, the number of votes received, and the percentage of the total, in order of votes received from highest to lowest\n- If the leading candidate has received more than 50% of the votes, what should you do?",
    "answer": "round = 1\neliminated = []\nstart_time = datetime.datetime.now()\n\nwhile True:\n    print(\"\\nRound:\", round)\n    for candidate in sorted(results):\n        results[candidate] = int(input(\"Enter the number of votes for \" + candidate + \": \"))\n    print(\"Number of Candidates:\", len(results))\n    total_votes = sum(results.values())\n    print(\"Total Votes:\", total_votes)\n    for candidate in sorted(results, key=results.get, reverse=True):\n        print(f\"{candidate}: {results.get(candidate)} ({results.get(candidate)/total_votes:.1%})\")\n    leader = max(results, key=results.get)\n    print(\"Candidate with the most votes:\", leader)\n    if results[leader]/total_votes > 0.5:\n        break\n    else:\n        loser = min(results, key=results.get)\n        print(\"Eliminating candidate with the least votes:\", loser)\n        del results[loser]\n        eliminated.append(loser)\n        round += 1\n\nend_time = datetime.datetime.now()\ntime_taken = end_time - start_time\nprint(f\"Voting rounds started at {start_time}, ended at {end_time}\")\nprint(f\"Time taken for voting: {time_taken}\")"
  },
  {
    "category": "q2",
    "question": "Display the results of the election, including:\n- The name of the winning candidate\n- The names of the eliminated candidates, along with the round number in which they were eliminated",
    "answer": "print(\"\\nWinner:\", leader)\n\nif len(eliminated) > 0:\n    print(\"Eliminated Candidates\")\n    print(\"Round Candidate\")\n    for round in range(0, len(eliminated)):\n        print(f\"{round+1:3} {eliminated[round]}\")\n\ndisplay_time = datetime.datetime.now()\nprint(f\"Election results displayed at {display_time}\")"
  }


]
